import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.VITE_SUPABASE_URL || process.env.SUPABASE_URL!;
const supabaseKey = process.env.VITE_SUPABASE_ANON_KEY || process.env.SUPABASE_SERVICE_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);

const JWT_SECRET = process.env.JWT_SECRET || process.env.SESSION_SECRET || 'fabzclean-secret-key-change-in-production';
const JWT_EXPIRY = '30d'; // 30 days - long session for better UX

export interface EmployeeJWTPayload {
    employeeId: string;
    username: string;
    role: 'admin' | 'franchise_manager' | 'factory_manager';
    franchiseId?: string;
    factoryId?: string;
}

export interface AuthEmployee {
    id: string;
    employeeId: string;
    username: string;
    role: 'admin' | 'franchise_manager' | 'factory_manager';
    franchiseId?: string;
    factoryId?: string;
    fullName?: string;
    email?: string;
    phone?: string;
    isActive: boolean;
}

export class AuthService {
    /**
     * Authenticate employee with username and password
     */
    static async login(username: string, password: string, ipAddress?: string): Promise<{ token: string; employee: AuthEmployee }> {
        // Fetch employee by username or email
        const { data: employees, error } = await supabase
            .from('auth_employees')
            .select('*')
            .or(`username.eq."${username}",email.eq."${username}"`);

        const emp = employees?.[0];

        if (error || !emp) {
            throw new Error('Invalid username or password');
        }

        // Check if account is active
        if (!emp.is_active) {
            throw new Error('Account is inactive');
        }

        // Verify password
        const isValidPassword = await bcrypt.compare(password, emp.password_hash);
        if (!isValidPassword) {
            throw new Error('Invalid username or password');
        }

        // Update last login
        await supabase
            .from('auth_employees')
            .update({ last_login: new Date().toISOString() })
            .eq('id', emp.id);

        // Log login action
        await this.logAction(emp.employee_id, emp.username, 'login', null, null, {}, ipAddress);

        // Generate JWT
        const payload: EmployeeJWTPayload = {
            employeeId: emp.employee_id,
            username: emp.username,
            role: emp.role,
            franchiseId: emp.franchise_id,
            factoryId: emp.factory_id,
        };

        const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRY });

        const employee: AuthEmployee = {
            id: emp.id,
            employeeId: emp.employee_id,
            username: emp.username,
            role: emp.role,
            franchiseId: emp.franchise_id,
            factoryId: emp.factory_id,
            fullName: emp.full_name,
            email: emp.email,
            phone: emp.phone,
            isActive: emp.is_active,
        };

        return { token, employee };
    }

    /**
     * Verify JWT and return employee info
     */
    static async verifyToken(token: string): Promise<EmployeeJWTPayload> {
        try {
            const payload = jwt.verify(token, JWT_SECRET) as EmployeeJWTPayload;

            // Verify employee still exists and is active
            const { data: emp, error } = await supabase
                .from('auth_employees')
                .select('is_active')
                .eq('employee_id', payload.employeeId)
                .single();

            if (error || !emp || !emp.is_active) {
                throw new Error('Invalid or inactive employee');
            }

            return payload;
        } catch (error) {
            throw new Error('Invalid or expired token');
        }
    }

    /**
     * Create a new employee (admin/manager only)
     */
    static async createEmployee(
        data: {
            username: string;
            password: string;
            role: 'admin' | 'franchise_manager' | 'factory_manager';
            franchiseId?: string;
            factoryId?: string;
            fullName?: string;
            email?: string;
            phone?: string;
        },
        createdByEmployeeId: string
    ): Promise<AuthEmployee> {
        // Hash password
        const passwordHash = await bcrypt.hash(data.password, 10);

        // Get creator's ID
        const { data: creator } = await supabase
            .from('auth_employees')
            .select('id')
            .eq('employee_id', createdByEmployeeId)
            .single();

        // Insert employee (employee_id will be auto-generated by trigger)
        const { data: emp, error } = await supabase
            .from('auth_employees')
            .insert({
                username: data.username,
                password_hash: passwordHash,
                role: data.role,
                franchise_id: data.franchiseId || null,
                factory_id: data.factoryId || null,
                full_name: data.fullName || null,
                email: data.email || null,
                phone: data.phone || null,
                created_by: creator?.id || null,
            })
            .select()
            .single();

        if (error || !emp) {
            throw new Error(`Failed to create employee: ${error?.message}`);
        }

        // Log creation
        await this.logAction(createdByEmployeeId, createdByEmployeeId, 'create_employee', 'employee', emp.employee_id, {
            username: emp.username,
            role: emp.role
        });

        return {
            id: emp.id,
            employeeId: emp.employee_id,
            username: emp.username,
            role: emp.role,
            franchiseId: emp.franchise_id,
            factoryId: emp.factory_id,
            fullName: emp.full_name,
            email: emp.email,
            phone: emp.phone,
            isActive: emp.is_active,
        };
    }

    /**
     * Update employee
     */
    static async updateEmployee(
        employeeId: string,
        data: Partial<{
            fullName: string;
            email: string;
            phone: string;
            franchiseId: string;
            factoryId: string;
            isActive: boolean;
        }>,
        updatedBy: string
    ): Promise<AuthEmployee> {
        const updateData: any = {};

        if (data.fullName !== undefined) updateData.full_name = data.fullName;
        if (data.email !== undefined) updateData.email = data.email;
        if (data.phone !== undefined) updateData.phone = data.phone;
        if (data.franchiseId !== undefined) updateData.franchise_id = data.franchiseId;
        if (data.factoryId !== undefined) updateData.factory_id = data.factoryId;
        if (data.isActive !== undefined) updateData.is_active = data.isActive;

        if (Object.keys(updateData).length === 0) {
            throw new Error('No fields to update');
        }

        const { data: emp, error } = await supabase
            .from('auth_employees')
            .update(updateData)
            .eq('employee_id', employeeId)
            .select()
            .single();

        if (error || !emp) {
            throw new Error('Employee not found');
        }

        // Log update
        await this.logAction(updatedBy, updatedBy, 'update_employee', 'employee', employeeId, data);

        return {
            id: emp.id,
            employeeId: emp.employee_id,
            username: emp.username,
            role: emp.role,
            franchiseId: emp.franchise_id,
            factoryId: emp.factory_id,
            fullName: emp.full_name,
            email: emp.email,
            phone: emp.phone,
            isActive: emp.is_active,
        };
    }

    /**
     * Reset employee password (admin only)
     */
    static async resetPassword(employeeId: string, newPassword: string, resetBy: string): Promise<void> {
        const passwordHash = await bcrypt.hash(newPassword, 10);

        const { error } = await supabase
            .from('auth_employees')
            .update({ password_hash: passwordHash })
            .eq('employee_id', employeeId);

        if (error) {
            throw new Error('Failed to reset password');
        }

        // Log password reset
        await this.logAction(resetBy, resetBy, 'reset_password', 'employee', employeeId, {});
    }

    /**
     * Get employee by ID
     */
    static async getEmployee(employeeId: string): Promise<AuthEmployee | null> {
        const { data: emp, error } = await supabase
            .from('auth_employees')
            .select('*')
            .eq('employee_id', employeeId)
            .single();

        if (error || !emp) {
            return null;
        }

        return {
            id: emp.id,
            employeeId: emp.employee_id,
            username: emp.username,
            role: emp.role,
            franchiseId: emp.franchise_id,
            factoryId: emp.factory_id,
            fullName: emp.full_name,
            email: emp.email,
            phone: emp.phone,
            isActive: emp.is_active,
        };
    }

    /**
     * List employees (filtered by requester's role)
     */
    static async listEmployees(requesterRole: string, franchiseId?: string, factoryId?: string): Promise<AuthEmployee[]> {
        let query = supabase
            .from('auth_employees')
            .select('*')
            .order('created_at', { ascending: false });

        // Filter by scope
        if (requesterRole === 'franchise_manager' && franchiseId) {
            query = query.eq('franchise_id', franchiseId);
        } else if (requesterRole === 'factory_manager' && factoryId) {
            query = query.eq('factory_id', factoryId);
        }
        // Admin sees all

        const { data, error } = await query;

        if (error) {
            throw new Error('Failed to list employees');
        }

        return (data || []).map(emp => ({
            id: emp.id,
            employeeId: emp.employee_id,
            username: emp.username,
            role: emp.role,
            franchiseId: emp.franchise_id,
            factoryId: emp.factory_id,
            fullName: emp.full_name,
            email: emp.email,
            phone: emp.phone,
            isActive: emp.is_active,
        }));
    }

    /**
     * Log employee action to audit log
     */
    static async logAction(
        employeeId: string,
        username: string,
        action: string,
        entityType: string | null,
        entityId: string | null,
        details: any,
        ipAddress?: string,
        userAgent?: string
    ): Promise<void> {
        await supabase
            .from('audit_logs')
            .insert({
                employee_id: employeeId,
                employee_username: username,
                action,
                entity_type: entityType,
                entity_id: entityId,
                details,
                ip_address: ipAddress || null,
                user_agent: userAgent || null,
            });
    }

    /**
     * Get audit logs (admin only)
     */
    static async getAuditLogs(filters?: {
        employeeId?: string;
        action?: string;
        startDate?: Date;
        endDate?: Date;
        limit?: number;
    }): Promise<any[]> {
        let query = supabase
            .from('audit_logs')
            .select('*')
            .order('created_at', { ascending: false });

        if (filters?.employeeId) {
            query = query.eq('employee_id', filters.employeeId);
        }
        if (filters?.action) {
            query = query.eq('action', filters.action);
        }
        if (filters?.startDate) {
            query = query.gte('created_at', filters.startDate.toISOString());
        }
        if (filters?.endDate) {
            query = query.lte('created_at', filters.endDate.toISOString());
        }
        if (filters?.limit) {
            query = query.limit(filters.limit);
        }

        const { data, error } = await query;

        if (error) {
            throw new Error('Failed to fetch audit logs');
        }

        return data || [];
    }
}
